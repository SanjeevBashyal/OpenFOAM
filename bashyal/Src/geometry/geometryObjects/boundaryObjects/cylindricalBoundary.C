#include "cylindricalBoundary.H"
#include "pointField.H"
#include "faceList.H"
#include "point.H"
#include "boundBox.H"
#include "List.H"
#include "mathematicalConstants.H" // For pi
#include "error.H"                 // For Warnings/Errors

namespace Bashyal
{

    using namespace Foam::constant; // Make pi accessible

    // --- Constructor ---

    cylindricalBoundary::cylindricalBoundary()
        : boundary(),                        // Call base class default constructor
          radius_(0.1),                      // Default value
          center_(Foam::point(1.0, 0.1, 0)), // Default value (0,0,0)
          zMin_(0.0),                        // Default value
          zMax_(1.0),                        // Default value
          nSegments_(32),                    // Default value
          patchTypes_()                      // Initialize patchTypes_ list (empty)
    {
        // Geometry (points_, faces_, boundBox_, patchTypes_) is NOT generated by default.
        // User must call initialize() explicitly.
        develop();
        initializePatchTypes();  // Initialize patch types for faces
        generateNefPolyhedron(); // Generate Nef polyhedron if needed
    }

    // --- Private Methods ---

    void cylindricalBoundary::initializePatchTypes()
    {
        patchTypes_.setSize(faces().size());
        // Assign the single patch type (20) to all faces
        forAll(patchTypes_, i)
        {
            patchTypes_[i] = 20; // Wall type
        }
    }

    void cylindricalBoundary::develop()
    {
        // Assumes radius_, center_, zMin_, zMax_, nSegments_ have been set

        // --- Basic Validation ---
        if (radius_ <= 0)
        {
            FatalErrorIn("cylindricalBoundary::develop()")
                << "Cylinder radius must be positive. Provided: " << radius_
                << Foam::exit(Foam::FatalError);
        }
        if (zMax_ <= zMin_)
        {
            FatalErrorIn("cylindricalBoundary::develop()")
                << "Cylinder zMax must be greater than zMin. Provided: zMin=" << zMin_
                << ", zMax=" << zMax_
                << Foam::exit(Foam::FatalError);
        }
        if (nSegments_ < 3)
        {
            FatalErrorIn("cylindricalBoundary::develop()")
                << "Number of segments (nSegments) must be at least 3 for cylinder approximation. Provided: "
                << nSegments_
                << Foam::exit(Foam::FatalError);
        }

        // --- Define Points ---
        // Total points = 2 (centers) + 2 * nSegments (edges)
        Foam::pointField points(2 + 2 * nSegments_);

        const Foam::scalar cx = center_.x();
        const Foam::scalar cy = center_.y();
        const Foam::scalar angleIncrement = 2.0 * mathematical::pi / nSegments_;

        // Point 0: Bottom center
        points[0] = Foam::point(cx, cy, zMin_);
        // Point 1: Top center
        points[1] = Foam::point(cx, cy, zMax_);

        // Points 2 to nSegments+1: Bottom edge points
        // Points nSegments+2 to 2*nSegments+1: Top edge points
        for (Foam::label i = 0; i < nSegments_; ++i)
        {
            Foam::scalar angle = i * angleIncrement;
            Foam::scalar cosAngle = Foam::cos(angle);
            Foam::scalar sinAngle = Foam::sin(angle);
            Foam::scalar px = cx + radius_ * cosAngle;
            Foam::scalar py = cy + radius_ * sinAngle;

            // Bottom edge point (index i + 2)
            points[i + 2] = Foam::point(px, py, zMin_);
            // Top edge point (index i + nSegments + 2)
            points[i + nSegments_ + 2] = Foam::point(px, py, zMax_);
        }

        // --- Define Faces ---
        // Total faces = nSegments (bottom) + nSegments (top) + 2 * nSegments (wall)
        Foam::label nTotalFaces = 4 * nSegments_;
        Foam::faceList faces(nTotalFaces);
        Foam::label faceIndex = 0;

        // Define Bottom Cap Faces (nSegments triangles)
        // Connect bottom center (0) to adjacent bottom edge points
        for (Foam::label i = 0; i < nSegments_; ++i)
        {
            Foam::label p1 = i + 2;                        // Current bottom edge point index
            Foam::label p2 = ((i + 1) % nSegments_) + 2;   // Next bottom edge point index (wrap around)
            faces[faceIndex++] = Foam::face({0, p1, p2}); // Order for outward normal (viewed from -Z)
        }

        // Define Top Cap Faces (nSegments triangles)
        // Connect top center (1) to adjacent top edge points
        for (Foam::label i = 0; i < nSegments_; ++i)
        {
            Foam::label p1 = i + nSegments_ + 2;                      // Current top edge point index
            Foam::label p2 = ((i + 1) % nSegments_) + nSegments_ + 2; // Next top edge point index
            // Reverse order for outward normal (viewed from +Z)
            faces[faceIndex++] = Foam::face({1, p2, p1});
        }

        // Define Curved Wall Faces (2 * nSegments triangles)
        // Create two triangles for each rectangular segment of the wall
        for (Foam::label i = 0; i < nSegments_; ++i)
        {
            Foam::label b1 = i + 2;                                   // Current bottom edge point index
            Foam::label b2 = ((i + 1) % nSegments_) + 2;              // Next bottom edge point index
            Foam::label t1 = i + nSegments_ + 2;                      // Current top edge point index
            Foam::label t2 = ((i + 1) % nSegments_) + nSegments_ + 2; // Next top edge point index

            // Triangle 1 (bottom-left, bottom-right, top-left)
            faces[faceIndex++] = Foam::face({b1, b2, t1});
            // Triangle 2 (bottom-right, top-right, top-left)
            faces[faceIndex++] = Foam::face({b2, t2, t1});
        }

        // --- Initialize Patch Types ---
        // Call this *after* faces_.setSize() and nTotalFaces is known
        // Assign to base class
        *static_cast<Foam::particleModels::indexedFaceSet*>(this) = Foam::particleModels::indexedFaceSet(points, faces);
        initializePatchTypes();
    }

    // --- Public Member Functions ---

    void cylindricalBoundary::initialize(
        Foam::scalar radius,
        const Foam::point &center,
        Foam::scalar zMin,
        Foam::scalar zMax,
        Foam::label nSegments)
    {
        // Store the parameters
        radius_ = radius;
        center_ = center; // Store the full point (Z component might be useful contextually)
        zMin_ = zMin;
        zMax_ = zMax;
        nSegments_ = nSegments;

        // Call develop to generate geometry based on the new parameters
        develop();
    }

    // --- Accessor Implementations ---

    const Foam::List<int> &cylindricalBoundary::getPatchTypes() const
    {
        // if (patchTypes_.empty()) {
        //     Foam::WarningIn("cylindricalBoundary::getPatchTypes()")
        //         << "Patch types accessed before geometry development."
        //         << Foam::endl;
        // }
        return patchTypes_;
    }

} // End namespace Bashyal
